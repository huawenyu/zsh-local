#!/bin/bash

SECONDS=0
scriptDir=$(dirname $0)
currDir=$(/usr/bin/pwd)
if [[ "$currDir" == "$HOME" ]]; then
    echo "Please enter a workdir, don't run from top-dir directly, e.g. '$HOME'."
	return
fi

# Change work dir to git-toplevel:
# - if git-repo, the git-toplevel is the work dir
# - others, it's current directory
workDir=$(git rev-parse --show-toplevel 2>/dev/null)
RESULT=$?
if [ $RESULT -eq 0 ]; then
	cd $workDir
else
	workDir=${currDir}
fi

_ZT_ARGS_Usage=$(cat <<-END
	Generating tags and cscope database...

	Sample:
	  tagme
	  tagme -a wiki     ### create .tags into HOME accross multiple wiki dirs
	  tagme -a md       ### markdown tag
	  tagme -a link
	  tagme -a save
	  tagme -a clean
	  tagme -f tag-update-file
END
)

if ! parse-args "$@" ; then
    echo "----------end--------------"
    return
fi
action=${_ZT_ARGS_Action}
one_file=${_ZT_ARGS_File}
tagscope=$_ZT_ARGS_Src
origDir=
dstDir=${workDir}
tmpDir='/tmp/tagme'

# Check with: $ ctags --list-kinds=c
#ctags -e --c-kinds=+defgstum -L ${FLIST} > /dev/null 2>&1
#
#v1. CTAGS_FLAG=--extra=+f
#v2. CTAGS_FLAG="--fields=+niazS --extra=+fq --c++-kinds=+px --c-kinds=+px --output-format=e-ctags"
# ctags disable add the function protocol by remove "+p" from c-kinds
#v3. CTAGS_FLAG="--fields=+niazS --extras=+Ffq --c++-kinds=+x --c-kinds=+x --output-format=e-ctags"
# improve c-kinds
CTAGS_FLAG="--fields=+niazS --extras=+Ffq --c++-kinds=+x --c-kinds=+defgstumx --output-format=e-ctags"
FLIST=".cscope.files"
ClangdFile="compile_commands.json"


## Other files:
#     tags.temp
#     tags.lock
#     GTAGS
#     GPATH
#     GRTAGS
#     .tagme       -- temperary build dir
#     .ccls-cache
#
tag_files=( \
  ".tags" \
  ".tagx" \
  ".cscope.files" \
  "tags" \
  "cscope.po.out" \
  "cscope.in.out" \
  "cscope.out" \
  "${ClangdFile}" \
  "${tmpDir}" \
)

clean_files=( \
  "${tmpDir}" \
)

trap cleanup EXIT
function cleanup() {
	trap - EXIT

	duration=$SECONDS
	echo "cleanup(action=$action time=$(($duration / 60))m:$(($duration % 60))s)"

	for cleanfile in "${clean_files[@]}" ;  do
		rm -fr "${cleanfile}" 2> /dev/null
	done

	# Backto the original current dir
	cd "$currDir"
}



# Copy/Save clangd compile commands
ClangdCompileFile() {
	if [ "$action" != "default" ] && [ "$action" != "link" ] && [ "$action" != "save" ]; then
		return
	fi

	skipClangNote="Skip '$ClangdFile': git-original-dir '${origDir}' not existed!"
	if ! chk-var ${origDir} ; then
		origDir=$(git config --get remote.origin.url)
		if ! chk-var ${origDir} || [ ! -d $origDir ]; then
			do-echo $skipClangNote
			return
		fi
	fi

	# Get the real path
	origDir2=$(readlink -f ${origDir})
	workDir2=$(readlink -f ${workDir})
	if [ "$action" == "default" ] || [ "$action" == "link" ]; then
		srcdir="$origDir"
		dstdir="$workDir"
		srcdir2="$origDir2"
		dstdir2="$workDir2"
		srcfile="${origDir}/${ClangdFile}"
		dstfile="${workDir}/${ClangdFile}"
	elif [ "$action" == "save" ]; then
		dstdir="$origDir"
		srcdir="$workDir"
		dstdir2="$origDir2"
		srcdir2="$workDir2"
		dstfile="${origDir}/${ClangdFile}"
		srcfile="${workDir}/${ClangdFile}"
	fi

	if [[ -f "$srcfile" ]]; then
		cp  $srcfile  $dstfile
		sed -i   "s/${srcdir//\//\\/}/${dstdir//\//\\/}/g"  $dstfile
		sed -i   "s/${srcdir2//\//\\/}/${dstdir2//\//\\/}/g"  $dstfile
		echo "[Done!] Clangd ${ClangdFile}: ${srcdir} -> ${dstdir}"
	else
		do-echo $skipClangNote
	fi
}


# Special handle: Rebuild the <file> assign by $1
#   - <file> should be full-path
if [[ -f "./.tags" && -f "$one_file" ]]; then
	# only rebuild tags when the file belong curr dir
	#if [[ "$1" == "$PWD/"* ]]; then
		pwdlen=${#PWD}
		LC_COLLATE=C ctags ${CTAGS_FLAG} -f .tags -a "./${one_file:$pwdlen}"
		#duration=$SECONDS
		#notify-send "Done tags R $(($duration / 60)):$(($duration % 60))."
	#fi

	return 0
fi


if [ "$action" == "clean" ] || [ "$action" == "link" ]; then
	for tagfile in "${tag_files[@]}" ;  do
		if [[ "$action" == "clean" ]]; then
			rm -f $tagfile 2> /dev/null
		elif [[ "$action" == "link" ]]; then
			if [ $tagfile == "${tmpDir}" ]; then
				continue
			fi

			if [[ -z ${origDir} ]]; then
				origDir=$(git config --get remote.origin.url)
				if [ ! -d $origDir ]; then
					echo "Dir '${origDir}' not existed, maybe we're not git-dir. Exit!"
					return 1
				fi
			fi

			srcfile="${origDir}/$tagfile"
			if [ ! -f ${srcfile} ]; then
				echo "File '${srcfile}' not existed, skip and continue!"
				continue
			elif [[ "$tagfile" == "$ClangdFile" ]]; then
				ClangdCompileFile
			else
				echo "Softlink '${srcfile}' -> '$tagfile'"
				rm -f $tagfile 2> /dev/null
				ln -s ${srcfile} $tagfile
			fi
		fi
	done

	return 0
fi


#########################################################
# Handle action=all/default/save/md {{{1
if [ "$action" != "default" ] && [ "$action" != "save" ] && [ "$action" != "md" ] && [ "$action" != "wiki" ]; then
	echo "Can't handle action '$action', Exit!"
	return 1
fi


# @return bool: return 0 for true and non-zero for false
PrepareFileList() {
	# Prepare file list
	rm -fr ${tmpDir} 2> /dev/null
	rm -f ${FLIST} 2> /dev/null
	mkdir -p ${tmpDir}

	# Issue "[: -ge: unary operator expected"
	# https://stackoverflow.com/questions/408975/compare-integer-in-bash-unary-operator-expected
	filecnt_c=0
	filecnt_python=0
	filecnt_rust=0
	filecnt_markdown=0
	if [[ "$action" == "wiki" ]]; then
		if has-var TLDR_PAGES_SOURCE_LOCATION; then
			dstDir="$HOME/.cache"
		else
			echo "Please set multiple wiki dirs into var 'TLDR_PAGES_SOURCE_LOCATION' under '$action' action, Exit!"
			return 1
		fi
	elif [ -f ${FLIST} ]; then
		filecnt_c=1024
	else
		filecnt_c=$(find . -maxdepth 3 -type f -name '*.c' | wc -l)
		filecnt_python=$(find . -maxdepth 3 -type f -name '*.py' | wc -l)
		filecnt_rust=$(find . -maxdepth 3 -type f -name '*.rs' | wc -l)
		filecnt_markdown=$(find . -maxdepth 3 -type f -name '*.md' | wc -l)
	fi

	# Rust
	if [ $filecnt_rust -ge 3 ]; then
		rusty-tags vi --output=".tags"
		#return 0
	elif [ $filecnt_c -ge 3 ]; then
		if [ $filecnt_c -lt 1024 ]; then
			clean_files+=("${FLIST}")
		fi

		case "$tagscope" in
		   "all")
			   find -L . -name '*.c' -o -name '*.cc' -o -name '*.h' -o -name '*.cpp' -o -name '*.hpp' > ${tmpDir}/cscope.f1
		   ;;
		   "wad")
			   find daemon/wad -name '*.c' -o -name '*.cc' -o -name '*.h' -o -name '*.cpp' -o -name '*.hpp' > ${tmpDir}/cscope.f1
		   ;;
		   *)
			   find . -name '*.c' -o -name '*.cc' -o -name '*.h' -o -name '*.cpp' -o -name '*.hpp' > ${tmpDir}/cscope.f1
		   ;;
		esac

		wad_c=$(grep 'daemon/wad' ${tmpDir}/cscope.f1 | wc -l)
		if [ $wad_c -ge 10 ]; then
			cat ${tmpDir}/cscope.f1             | \
				grep -v 'ccls-cache/'          | \
				grep -v 'wad/ui/stdin/'        | \
				grep -v 'wad/redirect/socket/' | \
				grep -v 'wad/test/'            | \
				grep -v 'wad/unittest/'        | \
				grep -v 'wad/cache/test/'      | \
				grep -v 'daemon/waagent/'      | \
				grep -v 'linux/'               | \
				grep -v 'linux-.*/'            | \
				grep -v 'compress/'            | \
				grep -v 'cooked/'              | \
				grep -v 'fortitest/'           | \
				grep -v 'linuxatm/'            | \
				grep -v 'sysctl/'              | \
				grep -v 'sysapi/stream_scan/tests/'  | \
				grep -v 'router/'              | \
				grep -v 'fortiweb/'            | \
				grep -v 'fortitest/'           | \
				grep -v 'tests/gtest/'         | \
				grep -v 'tests/'               | \
				grep -v 'tools/'               | \
				grep -v '/_' \
				> ${tmpDir}/cscope.f2
		else
			cat ${tmpDir}/cscope.f1            | \
				grep -v 'ccls-cache/'          | \
				grep -v '/_' \
				> ${tmpDir}/cscope.f2
		fi

		sort ${tmpDir}/cscope.f2 > ${tmpDir}/cscope.f3
		mv ${tmpDir}/cscope.f3 ${FLIST}
	elif [[ "$action" == "wiki" ]]; then
		clean_files+=("${tmpDir}/${FLIST}")

		# multiple wiki dir
		for oneDir in $(echo $TLDR_PAGES_SOURCE_LOCATION | tr ";,\ " "\n"); do
			if [[ $oneDir = file://* ]]; then
				oneDir=${oneDir:7:$}
				if [ -d $oneDir ]; then
					absDir=$(realpath "$oneDir")
					find -L "$absDir" -name '*.md' >> ${tmpDir}/cscope.f1
					continue
				fi
			fi
		done

		cat ${tmpDir}/cscope.f1            | \
			grep -v 'ccls-cache/'          | \
			grep -v '/_' \
			> ${tmpDir}/cscope.f2
		sort ${tmpDir}/cscope.f2 > ${tmpDir}/cscope.f3
		mv ${tmpDir}/cscope.f3 ${tmpDir}/${FLIST}
	elif [ $filecnt_markdown -ge 10 ]; then
		clean_files+=("${FLIST}")

		# current dir auto markdown
		for i in "$list"; do
			echo $i
		done
	else
		FLIST=""
	fi

	return 0
}


GenTag()
{
	rm -f "${dstDir}/.tags" 2> /dev/null
	rm -f "${dstDir}/.tagx" 2> /dev/null
	rm -f "${dstDir}/GTAGS" 2> /dev/null
	rm -f "${dstDir}/GPATH" 2> /dev/null
	rm -f "${dstDir}/GRTAGS" 2> /dev/null
	rm -f "${dstDir}/tags" 2> /dev/null
	rm -f "${dstDir}/tagx" 2> /dev/null
	rm -f "${dstDir}/tags.lock" 2> /dev/null
	rm -f "${dstDir}/tags.temp" 2> /dev/null

	#    /usr/bin/time gtags -f ${FLIST}
	#    /usr/bin/time global -u -L ${FLIST}
	rm -f "${dstDir}/.tags" 2> /dev/null
	rm -f "${dstDir}/.tagx" 2> /dev/null


	fList=${FLIST}
	if [ ! -z ${fList} ] && [ ! -f ${fList} ]; then
		fList=''
		if [ -f "${tmpDir}/${FLIST}" ]; then
			fList="${tmpDir}/${FLIST}"
		fi
	fi

	echo "Creating tag: ${dstDir}/.tagx"
	if [[ -z ${fList} ]]; then
		# tage-emacs, tags-vim, tagx-fuzzy
		#LC_COLLATE=C ctags -e ${CTAGS_FLAG} -f .tage -R . > /dev/null 2>&1
		LC_COLLATE=C ctags ${CTAGS_FLAG} -f "${dstDir}/.tags"  --exclude=.git --exclude=node_modules --exclude=.ccls-cache -R . > /dev/null 2>&1
		LC_COLLATE=C ctags --exclude=.git --exclude=node_modules --exclude=.ccls-cache -xR . > "${dstDir}/.tagx" 2>/dev/null
	else
		# tage-emacs, tags-vim, tagx-fuzzy
		#LC_COLLATE=C ctags -e ${CTAGS_FLAG} -L ${FLIST} -f .tage > /dev/null 2>&1
		LC_COLLATE=C ctags ${CTAGS_FLAG} -L ${fList} -f "${dstDir}/.tags" > /dev/null 2>&1
		LC_COLLATE=C ctags -xL ${fList} > "${dstDir}/.tagx" 2>/dev/null
	fi
}


GenScope()
{
	rm -f cscope.* 2> /dev/null

	if [[ -z ${FLIST} ]]; then
		cscope -bcqR > /dev/null 2>&1
	else
		cscope -kbq -i ${FLIST} > /dev/null 2>&1
	fi
}

GenCcls()
{
	rm -fr .ccls-cache 2> /dev/null
	ccls --index=. --init='{"clang":{"extraArgs": ["-fms-extensions", "-Wno-microsoft-anon-tag", "-Wno-microsoft", "-Wno-gnu-anonymous-struct"]}}' > /dev/null 2>&1
}

pidTag=0
PrepareFileList
if [[ $? -ne 0 ]]; then
	echo "PrepareFileList() fail! EXIT!"
	return 1
fi

if [[ "$action" == "default" || "$action" == "tag" || "$action" == "md" || "$action" == "wiki" ]]; then
	GenTag &
	pidTag=$!
fi

pidCscope=0
if [[ "$action" == "default" || "$action" == "cscope" ]]; then
	GenScope &
	pidCscope=$!
fi

if [ "$action" == "default" ] && [ "$action" == "save" ]; then
	ClangdCompileFile
fi

#pidCcls=0
#if [[ "$action" == "default" || "$action" == "ccls" ]]; then
#	GenCcls &
#	pidCcls=$!
#fi

# wait all parallel tasks done
jobs

if [ ${pidTag:-0} -gt 0 ]; then
	wait $pidTag
	echo "ctag done!"
fi
if [ ${pidCscope:-0} -gt 0 ]; then
	wait $pidCscope
	echo "cscope done!"
fi
if [ ${pidCcls:-0} -gt 0 ]; then
	wait $pidCcls
	echo "ccls done!"
fi

